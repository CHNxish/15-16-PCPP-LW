进程管理

进程(Process)：
A program in execution
区分进程：处理什么程序，什么数据，有什么状态

从数据结构和算法来看进程

new -> ready <-> running -> terminated
         ↑ waiting ↓

PCB 进程控制块(Process Control Block)
  process state + process number + program counter +
  registers + memory limits + list of open files + ...

进程调度队列 Job Queue Ready Queue Device Queue
进程一经创建，即在队列之间迁移，直到终止

-> Ready Queue -------Scheduler--------->            CPU -> end
    ↑                                                 ↓
    ↑ <- I/O <- I/O Queue <-          I/O Request  <- ↓
    ↑                     <-   Time Slice Expired  <- ↓
    ↑ <- Child Executes   <-         Fork A Child  <- ↓
    ↑ <- Interrupt Occurs <- Wait For On Interrupt <- ↓

进程上下文切换(Context Switch)

进程的工作
1.进程的创建
  父进程创建若干子进程，后者再创建其子进程，与此类推，构成了反映“传承”关系的一颗进程树
  子进程的资源：
    子进程共享父进程的所有资源
    子进程共享父进程部分资源
    子进程不从父进程共享资源，重新独立申请
  执行代码的执行顺序
    父进程和子进程并发执行
    父进程在子进程执行期间等待，在子进程运行完后，运行父进程
  进程终止
    子进程执行完最后一条指令后，要求操作系统将自己杀死(exit)
    父进程终止子进程的执行(abort)

进程间的合作
  独立进程不会影响其他进程的执行，也不被影响
  合作进程影响其他进程，或者受其他进程影响
  进程间合作式必须的，可以共享信息，加速执行任务，模块化，方便调用

IPC(Interprocess Communication)
  进程间通信IPC，提供一套进程通信，进程同步的机制  消息系统 send receive
同步通信 异步通信

CPU调度
  进程在执行中，总是在cpu密集型和I/O密集型交替运行，为了使CPU利用率最高，必须要CPU调度
调度器 Scheduler 需要调度器的时候
  执行 -> 等待
  执行 -> 就绪
  等待 -> 就绪
  进程终止
抢占式调度：拥有CPU资源的进程被迫交出CPU资源
非抢占式调度：拥有CPU资源的进程自愿交出CPU资源
调度算法：
  FCFS 先来先服务调度算法 first-come, first-served Scheduling
  SJF 最短作业优先调度算法 Shortest-Job-First Scheduling
  HRN 最高响应比调度算法 Highest response Ratio Next Scheduling
  Priority Scheduling 优先权调度算法:优先权较低的就绪进程可能永远得不到资源
       aging思想：就绪进程等在就绪队列里的时间，折算叠加到进程优先权，因此，等待在就绪队列里的进程，其优先权单调递增
  Round Robin 轮转调度算法
多层队列(Multilevel Queue)：把就绪队列拆分为几个队列，每个队列有其算法
多层反馈队列(Multilevel FeedBack Queue)：进程可在多个队列中迁移

实时(real-time)调度：
  硬实时调度：调度机制能够确保一个关键任务在给定的时间点前完成
  软实时调度：调度机制尽量给予关键任务最高优先级，尽量在预定时间点前完成

线程(Thread)


前趋图(Precedence Graph)用于描述进程之间执行的前后关系，是一种有向无循环图(Directed Acyclic Graph)
P1 -> P2 ->
   -> P3 -> P5 ->
   -> P4 -> P6 -> P8 ->
         -> P7       -> P9

初始结点 直接前趋 直接后继 终止结点 重量(程序量或结点执行时间)

前趋关系
P = {P1, P2, P3, P4, P5, P6, P7, P8, P9} ->= {(P1, P2), (P1, P3), (P1, P4), (P2, P5), (P3, P5), (P4, P6), (P4, P7), (P5, P8), (P6, P8), (P7, P9), (P8, P9)}
只有前面操作执行了后续操作才能执行

程序的并发执行及其特征
并发执行：一组在逻辑上相互独立的程序或程序段在执行过程中，其执行时间在客观上相互重叠，即一个程序段的执行尚未结束，另一个程序段的执行已经开始的这种执行方式

特征：1）间断性 2）失去封闭性 3）不可再现性

进程的特征和状态
特征：
1）结构特征 进程 = 程序段 + 数据段 + 进程控制块(Process Control Block) 往往提到的进程是进程的PCB
2）动态性 进程具有一定的生命期，“它由创建而产生，由调度而执行，由撤消而消亡”，而程序则指示一组有序指令的集合，并存放在某种介质中，其本身并不具有运动的含义，因而是静态的
3）并发性
4）独立性 能独立运行，独立分配资源和独立接受调度的基本单元
5）异步性

进程：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

状态：
1）就绪状态 进程分配了除CPU外的所有资源，只要获得CPU，便可执行。  就绪队列
2）执行状态 进程获得CPU，程序正在执行   单CPU单进程执行，多CPU多进程并行执行
3）阻塞状态 正在执行的进程由于发生某些事件而暂时无法继续执行，便放弃处理器处于暂停状态，即进程的执行发生阻塞

新状态 4）挂起状态
引起挂起状态的原因 1）终端用户的请求 2）父进程请求 3）负荷调节的需要 4）操作系统的需要