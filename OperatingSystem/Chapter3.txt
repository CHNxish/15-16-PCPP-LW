内存管理

内存管理模块提纲
  基本概念和背景
  连续区内存分配
  页式内存管理     ]
  页表结构        ]  非连续区内存分配
  段式内存管理     ]
  示例：Inter i386

程序必须装入内存后，才能(以进程为单位)被CPU解释，执行
CPU能够直接访问的，只有主存，寄存器
访问寄存器需要1个CPU时钟周期，很快
访问主存需要许多时钟周期，或者，需要若干机器周期
Cache位于主存，寄存器之间

指令和数据的地址绑定(Binding)
  指令和数据的地址绑定通常发生在3个阶段
    编译时绑定(学习汇编)：如果代码，数据的存放首地址已知，编译阶段即可确定绝对地址。如果首地址更变，则需要重新编译
    装入时绑定(学习单用户OS)：如果代码数据的存放首地址未知，编译阶段生成可重定位地址，装入时才确定绝对地址
    执行时绑定(学习OS原理)：如果允许进程在执行时迁移其代码或数据，那么地址绑定也在执行时进行，需要硬件装置支持其地址映射(e.g.，基地址寄存器和界限寄存器)

逻辑地址空间和物理地址空间
  区别于物理地址的地址空间的各种逻辑地址空间，是OS得以管理内存的必要条件
逻辑地址 - generated by the CPU, also referred to as virtual address
逻辑地址 - 非物理的各种地址标记
物理地址 - 内存单元接收到的地址，也就是说，在地址总线上传输的地址，以二进制形式表达
符号名和编译，汇编，连接，装入操作所产生的地址都是逻辑地址

存储管理单元(MMU)
  存储管理单元(Memory-Management Unit, MMU)是CPU内部的硬件装置，其功能是将虚拟地址转换成物理地址
  例如一种简单的MMU策略，在用户进程将逻辑地址送往地址总线前，MMU将重定位寄存器的值，加到这个逻辑地址
  用户进程只能处理逻辑地址，它无法获取真正的物理地址

动态连接(Dynamic Linking)
  进程即将用到的代码段，不被预先连接至程序中，只有到真正被调用时刻才连接
  需要动态连接库(Linux的.so文件，Windows的.dll)的配合

动态装入(Dynamic Loading)
  进程即将用到的子程序，不被预先装入，只有在真正被调用时才装入内存
  这样，进程本次运行中没有调用的子程序，就不会被装入内存
  更有效的利用了内存空间
  不需要操作系统的支持

交换(swapping) 换入(swap in) 换出(swap out)

连续区内存分配技术
  把主存划分成两个分区(partitions)
    操作系统占一个分区，通常驻留在主寸的低端，中断矢量也在低端
    用户进程占一个分区，通常在主存的高端
  多重分区(Multiple-partition)连续区分配
    Hole - 有效可分配的内存块
    多个长度不等的holes散布在内存各区域
    当一个进程申请进入主存时，OS选出一个hole，其长度足够容纳进程的映像，它就是分配给该进程的分区(partition)
    OS维护一些管理信息，包括：
      已经分配的分区
      可分配的分区(hole)
  如果在一串holes中找出一个能存储n个单元的hole？
    first-fit:找到第一个足够大的hole
    best-fit:找到足够满足该进程内存需求的最小的一个hole
    worst-fit:找到足够满足该进程内存需求的最大的一个hole
  碎片(Fragmentation)：
    内部碎片 
    外部碎片：紧缩(compaction)操作 代码，数据要支持可重定位

页式内存管理
  进程并不要求逻辑地址必须连续
  把物理地址等分成长度一致的数据块，称做页帧(frames)
  把逻辑地址等分成长度一致的数据块，称为页(pages)，与页帧的长度一致
  页的长度是2的次幂，取512字节或8192字节之间的数值

如何实现页表？ 页表必须驻留在内存中
  页表基地址寄存器(page-table base register)指向页表首地址
  页表长度寄存器(page-table length register)表示页表占用的空间的长度

TLB，关联存储器，支持并行存储

多级页表  哈希页表  反向页表

段式存储管理
  段式管理的机制
    一个逻辑地址划分成两部分：<段号，段内偏移量>
    段表(segment table) - 以段号为索引下标，将其映射至二维的物理地址
    段表项内容包括：
      基地址(base) - 记录该段在物理地址中的首地址
      界限(limit) - 记录该段的长度

虚拟内存的按需调页(demand page)
  按需调页的三种情况
    操作系统查找内核的数据结构，判断
      非法引用 => abort
      合法引用 => 缺页或者不缺页
  处理缺页(page fault)
    1.根据页表中的有效位(v i)，确定属于缺页情况
    2.操作系统查找内核的数据结构，找出一个空闲页帧
    3.把页面从外存调入空闲页帧
    4.更新内核的数据结构，更新进程的页表
    5.把页表中的有效位设为v
    6.缺页中断程序返回
    7.重新执行导致缺页的那条指令

页面置换的算法
  First-In-First-Out(FIFO) Algorithm先进先出算法：低效
  Optimal Algorithm最优化算法
  Least Recently Used Algorithm 最近最少使用算法
    近似LRU算法 First Chance和Second Chance

页帧分配
  一个进程至少需要一个极小数量级的页面，才能运行
  两种页帧分配策略：
    Fixed Allocation: Equal Allocation or Proportional Allocation
    Priority Allocation

抖动(Thrashing)：进程忙于换入，换出页面
