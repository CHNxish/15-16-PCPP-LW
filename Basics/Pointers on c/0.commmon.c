/*
二维数组：数组本身并不像矩阵一样在内存中排列，而是一种线性排列
比如一个[3][4]的数组，编译器对array[i][j]求值，实际上是从array地址上偏移i*4+j个量
所以编译器必须知道多维数组除了第一维以外的其他的SIZE
在用函数处理多维数组的时候，用(*array)[size]的方式
函数内直接用array[i][j]的方式
其实建议使用array[][SIZE]的方式作为函数形参，因为函数在传变量的时候是复制它的值，在传递
指针或者数组的时候是在传递它的地址，所以没有影响
例如array[]在声明处不能用array++这样的操作，而传入函数后却可以，因为编译器就是把传入的
形参当地址使用

struct，union，enum在定义的时候一定要在}后面加上;

const：作用方法是从左到右依次结合
char const *p;//const用于char，而不是用于*

掩码（mask）：一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位
利用掩码对二进制数字进行按照预期的变化

scanf("%d",i);
scanf("%c",c);
上面代码会出错，当第一个scanf输入值后，还附带一个换行符，它依旧在缓冲区中没有消除，
这个时候第二个scanf会将这个换行符读取，导致错误。
结果方法:1）在scanf后面加fflush(stdin); 2）getchar()
第一方法很可能没用，第二个方法效果比较显著，还有一个回到流指针首部的函数rewind(fp);
*/
