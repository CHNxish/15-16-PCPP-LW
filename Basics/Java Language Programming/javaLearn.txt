java库
java + javax

java.lang 编译环境自带包
java.util
javax.swing

char 双字节 boolean 布尔类型

java io
java.util.Scanner类 输入 System.in nextTypeName()方法
System.out.print() 输出
javax.swing.JOptionPane.showInputDialog()   返回值为String
javax.swing.JOptionPane.showMessageDialog()
javax.swing.JOptionPane.showConfirmDialog() 确定对话框
返回值
Yes按钮    JOptionPane.YES_OPTION     (0)
No按钮     JOptionPane.No_OPTION      (1)
Cancel按钮 JOptionPane.CANCEL_OPTION  (2)

GMT时间
System.currentTimeMillis() 返回值为long

随机数
Math.random() 返回值为double 0.0<= d <= 1.0
Math.random() * (n - m) + m 生成大于等于m小于n的随机数

java基本类型包装类
Byte Short Character Integer Long Float Double Boolean
Interger.parseInt(String s)

方法
public static main(String[] args){}
main方法可以调用其他类中的类 可以调用同类中的类

重载方法 方法名相同，参数列表不同
当多个同名方法存在时，编译器会选择最匹配的方法来使用，
如果找不到最合适的，就会产生歧义调用
Java中不存在重载运算符，只有string类可以用

Math类

TypeName data = new TypeName;
TypeName[] data = new TypeName[Size];
ClassName data = new ClassName(para);

char[] data = {....};
System.out.println(data); // print data

增强型for
// TypeName[] data = new TypeName[Size];
for(TypeName u : data){
    // use u do something
}

数组长度 data.length

数组复制
for循环
System.arraycopy(src, srcPos, dst, dstPos, length);
clone方法

java使用new后不需要delete，java有自动回收机制

java方法可变长参数
public static FuncName(TypeName... data);
data被当作数组使用，且TypeName是最后一个变量的类型
感觉只能传入相同类型的参数，没有c那么多功能，因为string和值类型同时传入没有办法区分

java.util.Arrays 专门用于Array的类 数组下标输入值和返回值都是0开始
Arrays.sort(arrayName); Arrays.sort(arrayName, left, right);
整个数组排序 从left到right-1排序 
Arrays.binarySearch(arrayName, key);
数组必须先正序排列好，如果找到key返回下标，如果没有找到返回-(插入点下标 + 1)，反正是个负值
Arrays.equals(arrayName1, arrayName2);
长度不同，每个位置不同，都会返回false
Arrays.fill(arrayName, fillValue); Arrays.fill(arrayName, left, right, fillValue);
填充fillValue给数组
Arrays类只能用于一维数组

// TypeName[][] data = new TypeName[size1][size2];
data.length 是(n - 1)维数组的个数
data[k].length 是第k个(n - 2)维数组的个数

锯齿数组 java中允许数组的长度不同
TypeName[][] data = new TypeName[size1][];
data[k] = new int[size2];

面对对象编程（OOP）
现实世界中可以明确标识的任意实体 - 对象
状态 state 行为 behavior
类定义不用在最后写";"  含有main方法的称为主类

在java中除了基本类型外，全部都是引用类型
基本类型赋值的时候，直接将对象的值赋给另一个对象
无论是数组，类等等，如果没有new分配空间，默认值是null，分配空间后值是分配后的地址值，类似c++中的指针
当一个引用类型给另一个相同引用类型赋值时，赋给的就是地址值，而另一个引用类型原本所指向的空间就会没用，而被java自动回收
一个源文件中只能有一个主类(main-class)
一个xxx.java文件中可以有多个类，但是被编译(javac)后，会产生多个xxx.class

Java库中的类
1)Data类 java.util.Date 1970.1.1开始算起  -- System.currentTimeMillis(): long
+Date()
+Date(elapseTime: long)

+toString(): String
+getTime(): long
+setTime(elapseTime: long): void

2)Random类 java.util.Random  --  Math.rand(): double (0.0 <= returnValue < 1.0)
+Random() 种子是当前时间
+Random(seed: long)

+nextInt(): int
+nextInt(n: int): int (0 < returnvalue < n)
+nextLong(): long
+nextDouble(): double
+nextFloat(): float
+nextBoolean: boolean

3)javax.swing.*类 JFrame JButtion JRadioButton JComboBox JList

static 类中的静态变量，静态常量，静态方法
static int data;
final static int data;
static int function(){}

Java中的包
package xxx.xxx; 生成目录
import xxx.xxx;  导入目录

javac -d . xxx.java 将xxx.java生成的xxx.class放在当前目录(.就是这个作用)
jar cvf xxx.jar xxx jar是打包命令 c:创建jar文件 v:生成详细信息 f:指定包名 xxx.jar:包的名字 xxx:目录
jar xvf xxx.jar
manifest.mf

私有修饰符private    将访问权限限定在它自己的类内
默认修饰符（无修饰符） 将访问权限限定在包内
公共修饰符public     没有限定权限

private只能用在类的成员上，public可以用在类和类的成员上，局部变量不应该用private和public修饰符
如果不希望类被构造，构造函数可以使用private私有化，函数可用static访问

ClassName data = new ClassName[Size];
for(int i = 0; i < data.length; i++){
	data[i] = new ClassName();
}

String类
String s = "Welcome to java!"; // 编译时就放入常量池中
String s = new String("Welcome to java!"); // 运行时利用这个字符串在堆中初始化s

+equals(s1: string): boolean
+compareTo(s1: string): int
+length(): int
+charAt(index: int): char
+concat(s1: String): String
+substring(beginIndex: int, endIndex:int): String
+toLowerCase(): String
+toUpperCase(): String
+trim(): String
+replace(oldChar: char, newChar:char): String
+replaceFirst(oldString: String, newString: String): String
+replaceAll(oldString: String, newString:String): String
+split(delimiter: String): String[]
+indexOf(ch: char): int
+lastIndexOf(ch: char): int

字符数组和字符串的转换
char[] chars = "Java".toCharArray();
String str = new String(new char[]{'J', 'a', 'v', 'a'});
String str = String.valueOf(new char[]{'J', 'a', 'v', 'a'});

+valueOf(c: char): String
+valueOf(data: char[]): String
+valueOf(d: double): String
+valueOf(f: float): String
+valueOf(i: int): String
+valueOf(l: long): String
+valueOf(b: boolean): String

Double.parseDouble(str: String): double
Integer.parseInt(str: String): int

String.format(format, item1, item2, ..., itemn)

正则表达式
java.util.regex类  和 String.matches()

java中每个基本数据类型都有一个包装类
Character Boolean Byte Short Integer Long Float Double

StringBuilder StringBuffer
两者都是可以被修改的字符串，StringBuilder速度大于StringBuffer，但是StringBuffer支持多线程，StringBulider支持单线程，类中成员函数一致

+StringBuilder()
+StringBuilder(capacity: int)
+StringBuilder(s: String)

+append(data: char[]): StringBuilder
+append(data: char[], offset: int, len: int): StringBuilder
+append(v: aPrimitiveType): StringBuilder
+append(s: String): StringBuilder
+delete(startIndex: int, endIndex: int): StringBuilder
+deleteCharAt(index: int): StringBuilder
+insert(index: int, data: char[], offset: int, len: int): StringBuilder
+insert(offset: int, data: char[]): StringBuilder
+replace(startIndex: int, endIndex: int, s: String): StringBuilder
+reverse(): StringBuilder
+setCharAt(index: int, ch: char): void

+toString(): String
+capacity(): int
+charAt(index: int): char
+length(): int
+setLength(newLength: int): void
+substring(startIndex: int, endIndex: int): String
+trimToSize(): void

File类 一个File对象可以是文件或者目录 java.io.File 不包括读写
+File(pathname: String)
+File(parent: String, child: String)
+File(parent: File, child: String)

+exists(): boolean // 存在
+canRead(): boolean // 存在且可读
+canWrite(): boolean // 存在且可写
+isDirectory(): boolean // File类是目录
+isFile(): boolean // File类是文件
+getName(): String
+getPath(): String
+getParent(): String
+lastModified(): long // 最后一次修改时间，从UNIX时间
+length(): long // 目录或文件大小，不存在则为0
+lastFile(): File[] // 返回File对象目录下的所有文件
+createNewFile()
+mkdir()
+delete(): boolean // 删除
+renameTo(): boolean // 重命名

PrintWriter类 java.io.PrintWriter
+PrintWriter(file: File)
+PrintWriter(filename: String)
+print(data: AllType): void
+println(data: AllType): void (比print多一个换行，windows是\r\n，UNIX是\n)
+close():void // 关闭

Scanner类 java.util.Scanner
+Scanner(source: File)
+Scanner(source: String)
+hasNext(): boolean
+next(): String
+nextTypeName(): TypeName
+close() // 关闭

String lineSeparator = System.getProperty("line.separator"); // 获取行分隔符
+useDelimiter(String regex); // 设置新的分隔符

在构造PrintWriter和Scanner时，可能会抛出I/O异常，必须在方法旁边写
example: public static void main(String[] args) throws Exception{}

要使一个类是不可变的，那么必须满足
1)所有数据域都是私有的
2)没有修改器方法
3)没有一个访问器方法，它会返回一个指向可变数据域的引用

类中非static变量可用this.data的形式使用
类中static变量可用ClassName.data的形式使用

如果一个类中有多个构造方法，通常，无参或参数少的构造方法可以用this(参数表)调用参数多的构造方法

面向对象编程设计：封装 继承 多态

类的抽象和封装

聚集和组合

/* Java语言程序设计：Teaching by example and learning by doing */
设计一个类 1）类名 2）类中元素 3）类中方法 4）实现类 5）测试类
example:Course class
1)Course
2)-courseName: String
-students: String[]
-numberOfStudents: int
3)+Course(courseName: String)
+getCourseName(): String
+addStudent(student: String): void
+dropStudent(student: String): void
+getStudents(): String[]
+getNumberOfStudents(): int
4)Course.java
public class Course{
	private String courseName;
	private String[] students = new String[100];
	private int numberOfStudents;

	public Course(String courseName){
		this.courseName = courseName;
		this.numberOfStudents = 0;
	}

	/* 由于String不可变，所以不用担心引用值被修改问题 */
	public String getCourseName(){
		return courseName;
	}

	public void addStudent(String student){
		students[numberOfStudents] = student;
		numberOfStudents++;
		System.our.println("Add is OK!");
	}

	public void dropStudent(String student){
		int index;

		for(index = 0; index < numberOfStudents; index++){
			if(students[index].equals(student)){
				break;
			}
		}

		if(index == numberOfStudents){
			System.out.println(courseName + " is no " + student);
		}
		else{
			for(int i = index; i < numberOfStudents; i++){
				students[i] = students[i + 1];
			}
			numberOfStudents--;

			System.out.println("Drop is OK!");
		}
	}

	public String[] getStudents(){
		return students;
	}

	public int getNumberOfStudents(){
		return numberOfStudents;
	}
}
5)TestCourse.java
public class TestCourse{
	public static void main(String[] args){
		Course course1 = new Course("Data Structures");
		Course course2 = new Course("Database Systems");

		course1.addStudent("Peter Jones");
		course1.addStudent("Brian Smith");
		course1.addStudent("Anne Kennedy");

		course2.addStudent("Peter Jones");
		course2.addStudent("Steve Smith");

		System.out.prinln("Number of students in course1: "
			+ course1.getNumberOfStudents());
		String[] students = course1.getStudents();
		for(int i = 0; i < course1.getNumberOfStudents(); i++){
			System.out.println(students[i] + ", ");
		}

		System.out.println();
		System.out.print("Number of students in course2: "
			+ course2.getNumberOfStudents());
	}
}

继承 extends
父类中的私有数据域在该类之外是不可被访问的
java中不允许多重继承（几个类派生一个子类），java只允许单一继承
父类中的数据域只能通过访问器/修改器使用
父类中的构造方法和方法通过super使用
构造方法链：子类的构造方法中，如果没有显式调用父类的构造方法，那么在构造方法中会在第一步隐式调用父类的无参构造方法
最好能为每个类提供一个无参构造方法（如果需要的话），以便对该类进行扩展同时避免错误
java不支持super.super，因为this和super是私有成员
在java中父类和子类中出现同名成员函数，如果参数类型都相同，那么子类会覆盖父类的同名成员函数，如果参数类型不相同，会重载方法
java中每个类都源于java.lang.Object类，如果定义一个类时没有显式继承某个类，那么隐式extends Object
Object类中有个成员函数是toString()，它会返回ClassType@MemoryAddress
因为基本源于Object，最好覆盖这个方法
特殊使用：如果定义了一个对象data，那么System.out.println(data) <=> System.out.println(data.toString())

多态 父类型的变量可以引用子类型的对象
Object o = new GeometricObject();
System.out.println(o.toString());
当父类的引用的实例是个子类时，调用的函数，会从子类向父类的方法寻找，直到找到同名函数
/* 匹配方法的签名和绑定方法的实现是两个对立的事情 */
引用变量的声明类型决定了编译时匹配哪个方法，编译器会在编译时，根据参数类型，参数个数和参数顺序找到匹配的方法，一个方法可能在几个子类中都被实现
java虚拟机在运行时动态绑定方法的实现，这是由变量的实际类型所决定的

Object o = new Student(); // true
Student s = (Student)o;   // true

instanceof
ClassName instanceof anotherClassName -> boolean
Object myObject = new Circle();
if(myObject instanceof Cirlce){
	System.out.println("The circle is diameter is " + ((Circle)myObject).getDiameter());
}

在子类中，使用签名equals(SomeClassName obj)覆盖Object中的equals是个常见的错误，这样只会重载这个方法，应该使用equals(Object obj)，方法内用(SomeClassName)obj.data来比较

java.util.ArrayList类 处理对象是Object 比普通数组更多的方法
+ArrayList()
+clear(): void

+add(o: Object):void
+add(index: int, o: Object): void
+set(index: int, o: Object): Object
+get(index: int): Object
+remove(o: Object): int
+remove(index: int): boolean

+isEmpty(): boolean
+size(): int
+contains(o: Object): boolean
+indexOf(o: Object): int
+lastIndexOf(o: Object): int
+toString(): String

类中修饰符 同一个类可访问 同一个包可访问 在子类内可访问 在不同包内可访问
public        true        true         true         true
protected     true        true         true         false
(default)     true        true         false        false
private       true        false        false        false

final 1)修饰变量是常量 2)修饰类是终极类(不能做父类)